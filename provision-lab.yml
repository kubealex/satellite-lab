- name: Download RHEL ISOs
  hosts: localhost
  vars_prompt:
    - name: offline_token
      prompt: What is your Offline Token? Leave this empty if you don't want to download ISOS (Check README)
      unsafe: yes
      private: yes      
  vars:
    checksum:
      rhel9: a387f3230acf87ee38707ee90d3c88f44d7bf579e6325492f562f0f1f9449e89
      rhel8: c324f3b07283f9393168f0a4ad2167ebbf7e4699d65c9670e0d9e58ba4e2a9a8

  tasks:
    - block:

      - name: Retrieve an access token
        uri:
          url: https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token
          body:
            grant_type: refresh_token
            client_id: rhsm-api
            refresh_token: "{{ offline_token }}"
          body_format: form-urlencoded
          method: POST
        register: response

      - name: Workaround to non-working uri module on success
        shell: 'curl -H "Authorization: Bearer {{ response.json.access_token }}" https://api.access.redhat.com/management/v1/images/{{ item }}/download'
        loop:
          - "{{ checksum.rhel8 }}"
          - "{{ checksum.rhel9 }}"
        register: imageurl

  # HANGING FOREVER
  #    - name: Retrieve image download URL
  #      ansible.builtin.uri:
  #        url: https://api.access.redhat.com/management/v1/images/{{ checksum.rhel8 }}/download
  #        return_content: true
  #        follow_redirects: all
  #        headers:
  #          Content-Type: application/json
  #          Authorization: 'Bearer {{ response.json.access_token }}'
  #          User-Agent: curl/7.61.1
  #      register: imageurl
      - name: Set result as facts
        ansible.builtin.set_fact:
          rhel8_url: "{{ (imageurl.results[0].stdout | from_json).body.href }}"
          rhel8_filename: "{{(imageurl.results[0].stdout | from_json).body.filename }}"
          rhel9_url: "{{ (imageurl.results[1].stdout | from_json).body.href }}"
          rhel9_filename: "{{ (imageurl.results[1].stdout | from_json).body.filename }}"

      - name: Retrieve RHEL ISO
        get_url:
          url: "{{ item.url }}"
          dest: "{{ playbook_dir }}/{{ item.os }}.iso"
        loop:
          - url: "{{ rhel8_url }}"
            os: "rhel8"
          - url: "{{ rhel9_url }}"
            os: "rhel9"
      when: offline_token is defined and offline_token != ""
      
- name: This play provisions VMs for Satellite demos
  hosts: localhost
  vars:
    network_cidr: 192.168.211.0/24
    packages:
    - python3-lxml
    - python3-netaddr
    - python3-libvirt
    - python3-pip
    - libvirt-devel
    - libvirt
    - qemu-kvm
    - virt-install
    - virt-manager
    domain: satellite.labs
    modules:
      - module: 01_satellite_instance
        instance: rhel8
        hostname: satellite   
      - module: 02_client_instance
        instance: rhel8
        hostname: el8-server    
      - module: 02_client_instance
        instance: rhel9
        hostname: el9-server

  become: true
  tasks:
    - name: Ensure required packages are in place
      yum: 
        name: "{{ packages }}"

    - name: Ensure libvirtd is running
      ansible.builtin.service: 
        name: libvirtd
        state: started
        enabled: true

    - name: Ensure libvirt can use root as user
      replace:
        path: /etc/libvirt/qemu.conf
        regexp: "{{ item.regexp }}"
        replace: "{{ item.line }}"
      loop:
        - regexp: '#user = "root"'
          line: 'user = "root"'
        - regexp: '#group = "root"'
          line: 'group = "root"'

    - name: Restart libvirtd service
      ansible.builtin.service: 
        name: libvirtd
        state: restarted
   
    - name: Create required folders
      ansible.builtin.file:
        state: directory
        path: "{{ playbook_dir }}/terraform/kickstart/{{ item.instance }}"
        recurse: true
      loop: "{{ modules }}"

    - name: Create symbolic link to RHEL image
      ansible.builtin.file:
        src: "{{ playbook_dir }}/{{ item.instance }}.iso"
        dest: "{{ playbook_dir }}/terraform/modules/{{ item.module }}/{{ item.instance }}.iso"
        state: link
      loop: "{{ modules }}"
          
    - name: Create a 1Mib file to store kickstart 
      community.general.filesize:
        path: "{{ playbook_dir }}/terraform/modules/{{ item.module }}/{{ item.instance }}-oemdrv.img"
        size: 1MiB
      loop: "{{ modules }}"
                         
    - name: Generate kickstart from template
      ansible.builtin.template:
        src: ks.cfg.j2
        dest: "{{ playbook_dir }}/terraform/kickstart/{{ item.instance }}/ks.cfg"
      loop: "{{ modules }}"
      vars:
        hostname: "{{ item.hostname }}"
          
    - name: Rebuild Kickstart config
      community.general.filesystem:
        fstype: ext2
        dev: "{{ playbook_dir }}/terraform/modules/{{ item.module }}/{{ item.instance }}-oemdrv.img"
        opts: -d {{ playbook_dir }}/terraform/kickstart/{{ item.instance }} -L OEMDRV
        force: true
      loop: "{{ modules }}"

    - name: Provision all terraform resources
      community.general.terraform:
        project_path: "terraform/"
        force_init: true
        variables:
          network_cidr: ' ["{{ network_cidr }}"]'
        state: present

    - name: Ensure required NM directories exist
      file:
        path: /etc/NetworkManager/{{ item }}
        state: directory
      loop: 
        - dnsmasq.d
        - conf.d      

    - name: Add Local resolver for the domain
      copy:
        content: server=/satellitedemo.labs/{{ network_cidr | next_nth_usable(1)}}
        dest: /etc/NetworkManager/dnsmasq.d/satellitedemo.conf

    - name: Configure NetworkManager for local DNS
      blockinfile:
        path: /etc/NetworkManager/conf.d/satellite-localdns.conf
        block: |
          [main]
          dns=dnsmasq

    - name: Restart NetworkManager to reload config
      service:
        name: NetworkManager
        state: restarted

    - name: Add servers to inventory
      add_host:
        hostname: "{{ item }}.{{ domain }}"
        ansible_user: root
        ansible_password: redhat
        ansible_ssh_common_args: '-o StrictHostKeyChecking=no'
        groups:
          - "servers"        
      loop:
        - satellite
        - el8-server
        - el9-server

    - name: Ensure to clean known_hosts
      known_hosts:
        host: "{{ item }}"
        path: ~/.ssh/known_hosts
        state: absent
      loop: "{{ groups['servers'] }}"

- name: Check connection to servers
  hosts: servers
  gather_facts: no
  tasks:
    - name: Waiting for installation to end, it can take time!
      wait_for_connection:
        timeout: 1800
        delay: 0

    - name: Setup sysadmin user to use sudo
      copy:
        content: '%wheel	ALL=(ALL)	NOPASSWD: ALL'
        dest: /etc/sudoers.d/wheelers
        mode: 0400
        owner: root
        group: root

    - ping:

    - name: Setup is ready
      debug:
        msg: "Setup completed, now you can proceed with post install steps"

